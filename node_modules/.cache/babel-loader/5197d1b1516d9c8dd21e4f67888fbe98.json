{"ast":null,"code":"'use strict';\n\nvar INC = 'inc';\nvar DEC = 'dec';\n/*\nconf: {\n        max: [number],\n        min: [number],\n        interval: [number], // update interval\n        step: [number], // update step e.g. is step = 2, it will inc/dec 2 every interval\n        type: [string], // inc: increment, dec: decrement\n        init: [number], // cannot be greater than max and smaller than min\n\tlastUpdate: [*number] // an optional timestamp to conrtol last update state\n}\n*/\n\nfunction TimedNumber(conf) {\n  this.validate(conf);\n  this.conf = conf;\n  this.current = this.conf.init;\n  this.lastUpdate = this.conf.lastUpdate || Date.now();\n} // public\n\n\nTimedNumber.prototype.getValue = function () {\n  switch (this.conf.type) {\n    case INC:\n      return this.calculateCurrentValueForInc();\n\n    case DEC:\n      return this.calculateCurrentValueForDec();\n  }\n}; // public\n\n\nTimedNumber.prototype.inc = function (value) {\n  if (!value || isNaN(value)) {\n    return false;\n  }\n\n  if (this.current + value > this.conf.max) {\n    return false;\n  }\n\n  if (this.current === this.conf.init) {\n    // initial mod\n    this.lastUpdate = Date.now();\n  } // if type is inc, increasing means recovering\n\n\n  this.current += value;\n  this.lastUpdate = Date.now();\n  return true;\n}; // public\n\n\nTimedNumber.prototype.dec = function (value) {\n  if (!value || isNaN(value)) {\n    return false;\n  }\n\n  if (this.current - value < this.conf.min) {\n    return false;\n  }\n\n  if (this.current === this.conf.init) {\n    // initial mod\n    this.lastUpdate = Date.now();\n  } // if type is dec, decreasing means recovering\n\n\n  this.current -= value;\n  this.lastUpdate = Date.now();\n  return true;\n}; // public\n\n\nTimedNumber.prototype.reset = function () {\n  this.current = this.conf.init;\n  this.lastUpdate = Date.now();\n}; // public\n\n\nTimedNumber.prototype.getMaxValue = function () {\n  return this.conf.max;\n}; // public\n\n\nTimedNumber.prototype.getMinValue = function () {\n  return this.conf.min;\n}; // public\n\n\nTimedNumber.prototype.getInterval = function () {\n  return this.conf.interval;\n}; // public\n\n\nTimedNumber.prototype.getStep = function () {\n  return this.conf.step;\n}; // public\n\n\nTimedNumber.prototype.getLastUpdate = function () {\n  return this.lastUpdate;\n}; // public\n\n\nTimedNumber.prototype.toObject = function () {\n  var obj = {};\n  obj.current = this.current;\n  obj.lastUpdate = this.lastUpdate;\n\n  for (var key in this.conf) {\n    obj[key] = this.conf[key];\n  }\n\n  return obj;\n}; // private\n\n\nTimedNumber.prototype.validate = function (conf) {\n  if (!conf.hasOwnProperty('max') || isNaN(conf.max)) {\n    throw new Error('invalid max: ' + conf.max);\n  }\n\n  if (!conf.hasOwnProperty('min') || isNaN(conf.min) || conf.min >= conf.max) {\n    throw new Error('invalid min: ' + conf.min);\n  }\n\n  if (!conf.hasOwnProperty('interval') || isNaN(conf.interval) || conf.interval <= 0) {\n    throw new Error('invalid interval: ' + conf.interval);\n  }\n\n  if (!conf.hasOwnProperty('type') || conf.type !== INC && conf.type !== DEC) {\n    throw new Error('invalid type: ' + conf.type);\n  }\n\n  if (!conf.hasOwnProperty('init') || isNaN(conf.init) || conf.init <= 0) {\n    throw new Error('invalid init: ' + conf.init);\n  }\n\n  if (!conf.hasOwnProperty('step') || isNaN(conf.step) || conf.step <= 0) {\n    throw new Error('invalid step: ' + conf.step);\n  }\n\n  if (conf.type === INC && conf.step > conf.max) {\n    throw new Error('step must not be greater than max');\n  }\n\n  if (conf.type === DEC && conf.step < conf.min) {\n    throw new Error('step must not be smaller than min');\n  }\n}; // private\n\n\nTimedNumber.prototype.calculateCurrentValueForInc = function () {\n  if (this.current === this.conf.max) {\n    return this.current;\n  }\n\n  var now = Date.now();\n  var timePast = now - this.lastUpdate;\n  var steps = Math.floor(timePast / this.conf.interval);\n  var incValue = this.conf.step * steps;\n  this.current = this.current + incValue <= this.conf.max ? this.current + incValue : this.conf.max;\n\n  if (incValue) {\n    this.lastUpdate = now;\n  }\n\n  return this.current;\n}; // private\n\n\nTimedNumber.prototype.calculateCurrentValueForDec = function () {\n  if (this.current === this.conf.min) {\n    return this.current;\n  }\n\n  var now = Date.now();\n  var timePast = now - this.lastUpdate;\n  var steps = Math.floor(timePast / this.conf.interval);\n  var decValue = this.conf.step * steps;\n  this.current = this.current - decValue >= this.conf.min ? this.current - decValue : this.conf.min;\n\n  if (decValue) {\n    this.lastUpdate = now;\n  }\n\n  return this.current;\n};\n\nmodule.exports = TimedNumber;","map":null,"metadata":{},"sourceType":"script"}